\chapter{Station au sol - Logiciel}
\label{chap:sas}

\section{Réalisation}

Le logiciel de la station au sol permet de recevoir les données de vol transmises par la fusée, d'afficher ces données en temps réel dans un interface graphique riche, de les sauvegarder dans un fichier et, enfin, de rejouer un vol.
Deux modes d'utilisation sont offerts à l'utilisateur: le mode temps réel et le mode replay.
Le code source de ce programme est écrit en \textit{Python 3}.
Celui-ci est portable et donc peut s'exécuter sur un
ordinateur portable autant que sur le Raspberry Pi de la station au sol
matérielle.
Les sections suivantes détaillent le fonctionnement de ce logiciel.

\subsection{Architecture producteur-consommateur}
La gestion du flot de données est basée sur une architecture producteur-consommateur.

Le producteur est responsable de produire les données de vol de façon continue et régulière, sous forme de paquets appelés \emph{RocketPackets}.
Deux types de producteurs existent, soient le producteur temps réel et le producteur replay.
Chacun d'eux est une implémentation d'une classe producteur abstraite.
Ainsi, les deux types de producteur sont interchangeable du point de vue du consommateur et ils sont libres de générer les nouveaux \emph{RocketPackets} à leur façon.
Le producteur temps réel lit le port série sur lequel est connectée l'antenne de réception et produit les paquets à partir du flot de données reçues en temps réel de la fusée (voir la section \ref{s:rocket_communication}).
Le producteur replay génère les paquets en lisant le fichier de sauvegarde d'un vol et simule une réception temps réel (voir la section \ref{s:mode_replay}).

Le consommateur, quand à lui, est unique et ne dépend pas du mode d'utilisation du logiciel.
Il consomme les paquets et extrait chacun des champs du \emph{RocketPackets}, qu'il groupe en listes.
Le consommateur effectue également les différents traitements sur ces données pour les rendre utilisables par les différents widgets de l'interface graphique (voir section \ref{s:traitement}).

Finalement, un contrôleur se charge d'orchestrer le producteur et le consommateur, en plus de rafraîchir l'interface graphique à intervalles réguliers et de gérer les entrées de l'utilisateur.

\subsection{Communication avec la fusée}
\label{s:rocket_communication}
TODO: updater le texte pour le forat 2018 du RocketPacket

La communication entre la fusée et l'ordinateur de la station au sol s'effectue à l'aide d'un émetteur-récepteur de type RFD-900.
Ce module de communication transfert les données reçues à l'ordinateur portable ou au Raspberry Pi par son port USB.
Cette communication est possible grâce à un protocole d'échange de \emph{RocketPackets}, qui sont des messages de longueur fixe dont le format est défini dans le tableau \ref{LogicielRealisationFormatPacket}.
Chaque \emph{RocketPacket} débute par un octet de démarrage, soit le caractère 's' en ASCII, et se termine par un octet de validation.
\\ \\
L'algorithme de réception des données est l'exécution en boucle des étapes suivantes:

\begin{enumerate}
    \item Lire un à un les octets du buffer du port USB jusqu'à obtenir l'octet de démarrage
    \item Lire les 109 octets du \emph{RocketPacket}
    \item Calculer la somme de contrôle
    \item Si le résultat de la somme de contrôle est valide, désérialiser l'objet \emph{RocketPacket} et ajouter celui-ci à la liste des paquets reçus.
    \item Sinon, rejeter le paquet.
\end{enumerate}

L'algorithme employé pour assurer la validité des données est une somme de contrôle très simple.
L'envoyeur additionne les 108 octets des données du paquet (excluant l'octet de démarrage), puis effectue une inversion logique du résultat.
L'octet obtenu est placé à la fin du \emph{RocketPacket}.
Lorsque le receveur reçoit le paquet, il additionne ces 109 octets.
Comme l'octet de validation est le complément de la somme sur 8 bits des 108 premiers octets, le résultat attendu est 255 (1111 1111).
Si le receveur obtient ce résultat, il conclut que les données ne sont pas corrompues.

\begin{table}
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Champ} & \textbf{Nombre d'octets} \\
        \hline
        Octet de départ & 1 \\
        &\\
        Timestamp & 4 \\
        Vitesse angulaire (x) & 4 \\
        Vitesse angulaire (y) & 4 \\
        Vitesse angulaire (z) & 4 \\
        Accélération (x) & 4 \\
        Accélération (y) & 4 \\
        Accélération (z) & 4 \\
        Altitude & 4 \\
        Latitude 1 & 4 \\
        Longitude 1 & 4 \\
        Latitude 2 & 4 \\
        Longitude 2 & 4 \\
        Température & 4 \\
        Date (heures) & 4 \\
        Date (minutes) & 4 \\
        Date (secondes) & 4 \\
        Quaternion (a) & 4 \\
        Quaternion (b) & 4 \\
        Quaternion (c) & 4 \\
        Quaternion (d) & 4 \\
        État du board d'acquisition 1 & 1 \\
        État du board d'acquisition 2 & 1 \\
        État du board d'acquisition 3 & 1 \\
        État du board d'alimentation 1 & 1 \\
        État du board d'alimentation 2 & 1 \\
        État du board du payload & 1 \\
        Non utilisé & 4 \\
        Non utilisé & 4 \\
        Vitesse angulaire payload (x) & 4 \\
        Vitesse angulaire payload (y) & 4 \\
        Vitesse angulaire payload (z) & 4 \\
        Non utilisé & 1 \\
        Non utilisé & 1 \\
        &\\
        Octet de validation & 1 \\
        \hline
    \end{tabular}
    \caption{Format du RocketPacket}
    \label{LogicielRealisationFormatPacket}
\end{table}

\subsection{Sauvegarde et chargement de données de vol}


\subsection{Mode \textit{replay}}
\label{s:mode_replay}


\subsection{Traitement des données}
\label{s:traitement}


\subsection{Interface graphique}


\section{Rétrospective}

\subsection{Points forts}


\subsection{Points à améliorer}
